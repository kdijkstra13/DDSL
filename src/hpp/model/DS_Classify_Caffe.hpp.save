#pragma once
#include "h/model/DS_Classify_Caffe.h"

#include "hpp/model/DS_Model.hpp"
#include "hpp/lib/DS_Image_PNG.hpp"

#include "caffe/layers/memory_data_layer.hpp"
#include "caffe/layers/inner_product_layer.hpp"
#include "caffe/layers/conv_layer.hpp"

#include "caffe/sgd_solvers.hpp"
#include "caffe/solver_factory.hpp"
#include "caffe/util/db.hpp"

#include "boost/bind.hpp"

//#include "caffe/util/io.hpp"
#include "google/protobuf/text_format.h"
#ifndef CPU_ONLY
  #include "cuda.h"
  #include "cuda_runtime.h"
#endif

//#include "direct.h"

using namespace std;
using namespace DSTypes;
using namespace DSFunc;
using namespace DSLang;
using namespace DSUtil;
using namespace DSLib;
using namespace caffe;
using namespace db;

namespace DSTypes {
	static const char* UnitTypeStr[] = {"TanH", "Sigmoid", "ReLU"};
	static const char* SolverTypeStr[] = {"SGD", "AdaDelta", "AdaGrad", "Adam", "Nesterov", "RMSProp"};
	static const char* LearnRatePolicyStr[] = {"fixed", "step", "exp", "inv", "multistep", "poly", "sigmoid"};
	static const char* BackendStr[] = {"LMDB", "LevelDB"};
	static const char* DBModeStr[] = {"Append", "New"};
}

namespace DSFunc {

	inline DSLib::Matrix<Int32> getCaffeGPUs() {
		int count;
		Matrix<Int32> ret;
		cudaGetDeviceCount(&count);
		for (int i = 0; i < count; ++i) {
		  ret | (Int32)i;
		}
		return ret;
	}

	inline DSLib::Matrix<Int32> setCaffeGPUs(const DSLib::Matrix<Int32> &gpus = DSLib::Matrix<Int32>(), const bool details=true) {
		Matrix<Int32> gpus2, gpus3;
#ifndef CPU_ONLY
		gpus2 = getCaffeGPUs();
		if (~gpus == 0)
			gpus3 = gpus2;
		else {
			DSFunc::setIntersection(gpus3, const_cast<Matrix<Int32>&>(gpus), gpus2);
			if (~gpus3 != ~gpus)
				cout << "Warning: Not all GPUs were available." << endl;
		}
#ifndef USE_NCCL
		if (~gpus3 > 1) {
			cout << "Warning: Cannot use multi-gpu when not built using USE_NCCL." << endl;
			gpus3.resize(1U, 1U);
		}
#endif
		cout << "Using GPUs: " << gpus3.print();
		if (details) {
			for (auto gpu = gpus3.vec().begin(); gpu != gpus3.vec().end(); gpu++) {
				caffe::Caffe::SetDevice(*gpu);
				caffe::Caffe::DeviceQuery();
			}
		}
		if (~gpus3 > 0) {
			caffe::Caffe::set_mode(caffe::Caffe::GPU);
			caffe::Caffe::SetDevice(gpus3.vec(0));
			caffe::Caffe::set_solver_count(~gpus3);
		} else
			cout << "Warning: No GPUs detected" << endl;
#else
		cout << "Warning: Running CPU Only." << endl;
		caffe::Caffe::set_mode(caffe::Caffe::CPU);
#endif
		return gpus3;
	}

	inline DB * openDB(const String filename, const DBMode mode, const Backend be) {
		const String f = "openDB";
		DB * dat;
		switch (be) {
		case beLMDB: dat = GetDB(DataParameter_DB_LMDB); break;
		case beLevelDB: dat = GetDB(DataParameter_DB_LEVELDB); break;
		default: throw Error(ecIncompatible, f, "Unknown database backend");
		}
		if (MKDIR(filename.c_str()) == 0) {
			RMDIR(filename.c_str());
			if (mode == dbmNew || mode == dbmAppendOrNew)
				dat->Open(filename, NEW);					
			else
				throw Error(ecUnexpected, "writeImageDB", SS("Database " << filename << " does not exist"));				
		} else {
			if (mode == dbmAppend || mode == dbmAppendOrNew)
				dat->Open(filename, WRITE);
			else
				throw Error(ecUnexpected, "writeImageDB", SS("Database " << filename << " already exists"));
		}
		return dat;
	}

	template <typename T, typename TInt, template <typename, typename> class TImg>
	inline void writeImageDB(DSLib::Matrix<TImg<T, TInt>, TInt> &images, DSLib::Matrix<T, TInt> &labels, const DSTypes::String &filename, const ProgressCallback &progressCallback, const DBMode mode, const Backend be) {
		const String f = "writeImageDB";
		if (images.rows.count() == 0)
			return;
		bool hasLabels = (labels.vec().count() != 0);
		DB * dat = nullptr;
		Transaction * trans = nullptr;
		dat = openDB(filename, mode, be);
		trans = dat->NewTransaction();

		try {			
			//Investigate dataset
			TInt channels = 0;
			TInt width = 0;
			TInt height = 0;
			for (auto img_it = images.rows[0]->begin(); img_it != images.rows[0]->end(); img_it++) {
				channels += img_it->getChannelCount();
				bool hadImage = img_it->hasImage();
				if (!hadImage) img_it->loadImage();
				if (width == 0) {
					width = img_it->getImageWidth();
					height = img_it->getImageHeight();
				}
				if (width != img_it->getImageWidth() || height != img_it->getImageHeight())
					throw Error(ecIncompatible, f, SS("Cannot use images with varying sizes: " << height << "x" << width << " != " << img_it->getImageHeight() << "x" << img_it->getImageWidth()));
				if (!hadImage) img_it->freeImage();
			}
			//Initialize datum
			Datum sample;
			sample.set_channels(channels);
			sample.set_width(width);
			sample.set_height(height);

			TInt rowIdx = 0;
			TInt bytes = 0;
			TInt min = 0;
			TInt max = images.rows.count();
			TInt p = 0;
			for (auto r = images.rows.begin(); r != images.rows.end(); r++, rowIdx++, p++) {
				Matrix<T, TInt> mcimg;
				//Concat all images in a row
				for (auto cell = r->begin(); cell != r->end(); cell++) {
					bool hadImage = cell->hasImage();
					if (!hadImage) cell->loadImage();
					if (cell->getChannelCount() > 1)
						cell->convertRGBToPlanarV();
					mcimg ^ *cell;
					if (!hadImage) cell->freeImage();
				}
				//Assign Matrix to Datum
				sample.clear_data();
				sample.clear_float_data();
				for (auto it = mcimg.rows->begin(); it != mcimg.rows->end(); it++) {
					sample.add_float_data((Float)*it);
				}
				if (hasLabels)
					sample.set_label((google::protobuf::int32)labels.vec(rowIdx));
				//Write to Transaction
				string out;
				sample.SerializeToString(&out);
				trans->Put(SS(rowIdx), out);
				bytes += height * width * channels * sizeof(Float);
				if (bytes > CHUNK_BYTES) {
					trans->Commit();
					delete trans;
					trans = dat->NewTransaction();
					bytes = 0;
				}
				progressCallback(min, max, p);
			}
			if (bytes > 0)
				trans->Commit();
			freeAndNull(&dat);
			freeAndNull(&trans);
			progressCallback(min, max, max);
		} catch (const exception &e) {
			freeAndNull(&dat);
			freeAndNull(&trans);
			throw Error(ecGeneral, f, e.what());
		}
	}

	template <typename TInt>
	void dbStats(const String &filename, TInt &size, TInt &width, TInt &height, TInt &channels, bool &hasLabels, const DSTypes::Backend be) {
		const String f = "dbStats";
		DB * dat = nullptr;
		Cursor * cur = nullptr;
		size = 0;
		channels = 0;
		width = 0;
		height = 0;
		hasLabels = false;
		try {
			switch (be) {
				case beLMDB: dat = GetDB(DataParameter_DB_LMDB); break;
				case beLevelDB: dat = GetDB(DataParameter_DB_LEVELDB); break;
				default: throw Error(ecIncompatible, f, "Unknown database backend");
			}
			dat->Open(filename, READ);
			Cursor * cur = dat->NewCursor();
			Datum sample;
			cur->SeekToFirst();
			if (cur->valid()) {
				sample.ParseFromString(cur->value());
				hasLabels = sample.has_label();
				channels = sample.channels();
				width = sample.width();
				height = sample.height();
			}
			while (cur->valid()) {
				cur->Next();
				size++;
			}
			freeAndNull(&cur);
			freeAndNull(&dat);
		} catch (const exception &e) {
			freeAndNull(&cur);
			freeAndNull(&dat);			
			throw Error(ecGeneral, "WriteDB", e.what());
		}
	}

	template <typename T, typename TInt, template <typename, typename> class TImg>
	inline void readImageDB(DSLib::Matrix<TImg<T, TInt>, TInt> &images, DSLib::Matrix<T, TInt> &labels, const DSTypes::String &filename, const DSTypes::String &cacheFolder, const ProgressCallback &progressCallback, const DSTypes::Backend be) {
		const String f = "readImageDB";
		DB * dat = nullptr;
		Cursor * cur = nullptr;
		if (cacheFolder != "")
			CHDIR(cacheFolder.c_str());
		try {
			//Get database content
			Datum sample;
			TInt rowCount = 0;
			TInt colCount = 0;
			TInt w = 0;
			TInt h = 0;
